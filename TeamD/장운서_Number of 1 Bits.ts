function hammingWeight(n: number): number {
	let count = 0
	while (n !== 0) {
		n = n & (n - 1)
		count++
	}

	return count
}

hammingWeight(11)

// 📌 1. 문제 다시 간단히 정리
// 양의 정수 n이 주어졌을 때, 이 숫자를 이진수(binary) 로 바꿨을 때
// 1이 몇 개인지 세는 문제야.

// 예를 들어:

// n = 11 → 이진수: 1011 → 1의 개수: 3

// n = 128 → 이진수: 10000000 → 1의 개수: 1

// 📘 2. 필요한 기초 지식
// ✅ 이진수 개념 (Binary)
// 숫자를 0과 1로 표현하는 방식

// 10진수 → 2진수로 변환하려면 2로 나눈 나머지를 거꾸로 읽기

// 예:
// 11 → 2로 나눠가면 → 나머지: 1 1 0 1 → 거꾸로: 1011

// ✅ 비트 연산자 (중요!)
// 연산자	의미	예시
// &	AND	1 & 1 = 1, 1 & 0 = 0
// >>	오른쪽으로 비트를 민다	1011 >> 1 = 0101
// >>>	부호 무시하고 오른쪽 시프트	(음수 걱정 없는 버전)

// ✋ 어떻게 풀지 감이 안 올 땐?
// 아래처럼 시뮬레이션을 해보면 좋아:

// 예) n = 11

// 1단계: 11을 이진수로 → 1011

// 이걸 하나하나 보면서 1인 비트를 세는 거야.

// plaintext
// 복사
// 편집
// 1011
//  ↑ ↑ ↑   (1의 개수 = 3)
// ✅ 우리가 원하는 건?
// n에서 1의 개수를 셀 수 있는 반복문을 짜는 것!

// 🔁 가장 쉬운 풀이 구조
// let count = 0;
// while (n > 0) {
//   if (n % 2 === 1) count++; // 마지막 비트가 1이면 증가
//   n = Math.floor(n / 2);     // 오른쪽으로 1칸 민다 (2로 나누기)
// }
// return count;
// 또는 비트 연산을 쓰면:

// let count = 0;
// while (n > 0) {
//   if ((n & 1) === 1) count++; // 마지막 비트 확인
//   n = n >>> 1;                // 오른쪽으로 1칸 밀기
// }
// 🚀 공부 방법 추천
// 비트 연산 기초부터 익히기

// &, |, ^, ~, >>, >>>, << 의 의미 이해

// 이진수 변환 연습 (10 → 1010, 15 → 1111 등)

// 직접 손으로 써보기

// 예를 들어 13이 1101이니까, while 문을 돌면서 어떻게 count가 늘어나는지 적어봐.

// 작은 숫자로 테스트하며 디버깅

// n = 5, n = 7, n = 1 같은 값으로 콘솔 찍어보기

// 단계별로 익히기

// 처음엔 문자열 변환 방법 → 그다음은 비트마스크 → 그다음은 커니건 알고리즘
